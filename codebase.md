# .eslintignore

```
node_modules
yarn.lock
package-lock.json

*.js
*.d.ts
```

# .eslintrc

```
{
    "env": {
      "browser": true,
      "es2021": true
    },
    "extends": [
      "eslint:recommended",
      "plugin:@typescript-eslint/recommended",
      "plugin:prettier/recommended"
    ],
    "parser": "@typescript-eslint/parser",
    "parserOptions": {
      "ecmaVersion": 12,
      "sourceType": "module"
    },
    "plugins": ["@typescript-eslint", "prettier"],
    "rules": {
      "prettier/prettier": "error"
    }
  }
  
```

# .gitattributes

```
# Auto detect text files and perform LF normalization
* text=auto

```

# .gitignore

```
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*


tsconfig.tsbuildinfo

test-storage.json*
```

# .husky\_\.gitignore

```
*
```

# .husky\_\applypatch-msg

```
#!/usr/bin/env sh
. "$(dirname "$0")/h"
```

# .husky\_\commit-msg

```
#!/usr/bin/env sh
. "$(dirname "$0")/h"
```

# .husky\_\h

```
#!/usr/bin/env sh
[ "$HUSKY" = "2" ] && set -x
n=$(basename "$0")
s=$(dirname "$(dirname "$0")")/$n

[ ! -f "$s" ] && exit 0

if [ -f "$HOME/.huskyrc" ]; then
	echo "husky - '~/.huskyrc' is DEPRECATED, please move your code to ~/.config/husky/init.sh"
fi
i="${XDG_CONFIG_HOME:-$HOME/.config}/husky/init.sh"
[ -f "$i" ] && . "$i"

[ "${HUSKY-}" = "0" ] && exit 0

export PATH="node_modules/.bin:$PATH"
sh -e "$s" "$@"
c=$?

[ $c != 0 ] && echo "husky - $n script failed (code $c)"
[ $c = 127 ] && echo "husky - command not found in PATH=$PATH"
exit $c

```

# .husky\_\husky.sh

```sh
echo "husky - DEPRECATED

Please remove the following two lines from $0:

#!/usr/bin/env sh
. \"\$(dirname -- \"\$0\")/_/husky.sh\"

They WILL FAIL in v10.0.0
"
```

# .husky\_\post-applypatch

```
#!/usr/bin/env sh
. "$(dirname "$0")/h"
```

# .husky\_\post-checkout

```
#!/usr/bin/env sh
. "$(dirname "$0")/h"
```

# .husky\_\post-commit

```
#!/usr/bin/env sh
. "$(dirname "$0")/h"
```

# .husky\_\post-merge

```
#!/usr/bin/env sh
. "$(dirname "$0")/h"
```

# .husky\_\post-rewrite

```
#!/usr/bin/env sh
. "$(dirname "$0")/h"
```

# .husky\_\pre-applypatch

```
#!/usr/bin/env sh
. "$(dirname "$0")/h"
```

# .husky\_\pre-auto-gc

```
#!/usr/bin/env sh
. "$(dirname "$0")/h"
```

# .husky\_\pre-commit

```
#!/usr/bin/env sh
. "$(dirname "$0")/h"
```

# .husky\_\pre-merge-commit

```
#!/usr/bin/env sh
. "$(dirname "$0")/h"
```

# .husky\_\pre-push

```
#!/usr/bin/env sh
. "$(dirname "$0")/h"
```

# .husky\_\pre-rebase

```
#!/usr/bin/env sh
. "$(dirname "$0")/h"
```

# .husky\_\prepare-commit-msg

```
#!/usr/bin/env sh
. "$(dirname "$0")/h"
```

# .husky\pre-commit

```
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

echo 'ðŸ—ï¸ðŸ‘· Styling, testing and building your project before committing'

# Run Prettier
npm run format ||
(
    echo 'âŒ Prettier check failed. Run npm run format, add changes and try to commit again.';
    false;
)

# Run ESLint
npm run lint:fix ||
(
    echo 'âŒ ESLint check failed. Make the required changes listed above, add changes and try to commit again.';
    false;
)

# Check Prettier standards
npm run check-format ||
(
    echo 'âŒ Prettier check failed. Run npm run format, add changes and try to commit again.';
    false;
)

# Check ESLint Standards
npm run check-lint ||
(
    echo 'âŒ ESLint check failed. Make the required changes listed above, add changes and try to commit again.';
    false;
)

# Check tsconfig standards
npm run check-types ||
(
    echo 'âŒ TypeScript check failed. Make the changes required above.';
    false;
)

# If everything passes... Now we can commit
echo 'âœ… All checks passed. Committing now.'
```

# .prettierignore

```
*.md
.localstack
.aws
# dependencies
node_modules
/.pnp
.pnp.js

# production
build
dist

# misc
.DS_Store
*.pem
.eslintcache
.vscode

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*
*.html

*.js
*.d.ts

*.yaml
*.yml

.eslintrc
.prettierrc
```

# .prettierrc

```
{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2
}

```

# CHANGELOG.md

```md
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [1.0.0] - 2024-12-22

### Added
- Initial release
- Record and playback functionality
- Synchronous and asynchronous function support
- Special type preservation (Set, Map, Date, RegExp)
- Circular reference handling
- Storage file backup system
- Comprehensive error handling
- TypeScript support

### Security
- Secure argument hashing
- Safe storage file handling
- Atomic writes for data integrity
```

# commitlint.config.js

```js
module.exports = {
    extends: ['@commitlint/config-conventional']
  };
```

# CONTRIBUTING.md

```md
# Contributing to Beatbox

## Development

1. Clone the repository
2. Install dependencies: `npm install`
3. Run tests: `npm test`
4. Build: `npm run build`

## Release Process

We use semantic versioning (semver):
- MAJOR version (1.0.0) for incompatible API changes
- MINOR version (0.1.0) for backwards-compatible functionality additions
- PATCH version (0.0.1) for backwards-compatible bug fixes

### Creating a Release

1. Ensure all tests pass: `npm test`
2. Update version in package.json:
   \`\`\`bash
   # For patch release (bug fixes)
   npm version patch

   # For minor release (new features)
   npm version minor

   # For major release (breaking changes)
   npm version major
   \`\`\`
   This will:
   - Update package.json version
   - Create a git tag
   - Create a version commit

3. Push changes and tags:
   \`\`\`bash
   git push && git push --tags
   \`\`\`

4. Publish to NPM:
   \`\`\`bash
   npm publish
   \`\`\`

### Release Checklist

- [ ] All tests pass
- [ ] Documentation is updated
- [ ] CHANGELOG.md is updated
- [ ] Version is updated
- [ ] Git tag is created
- [ ] Changes are pushed
- [ ] Package is published

## Version Guidelines

### Patch Releases (0.0.x)
- Bug fixes
- Performance improvements
- Documentation updates

### Minor Releases (0.x.0)
- New features
- Non-breaking API additions
- Deprecation notices

### Major Releases (x.0.0)
- Breaking API changes
- Major architectural changes
- Dropping support for older Node.js versions
```

# LICENSE

```
MIT License

Copyright (c) 2024 andrewlwn77

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

# package.json

```json
{
  "name": "beatbox-recorder",
  "version": "1.0.0",
  "description": "Record and playback function calls for testing and mocking",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "commit": "cz",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "prepare": "npm run build && husky install",
    "prepublishOnly": "npm test",
    "preversion": "npm test",
    "version": "git add -A src",
    "postversion": "git push && git push --tags",
    "format": "prettier --write \"**/*.{js,ts,tsx,json}\"",
    "check-format": "prettier --check .",
    "check-types": "tsc --project tsconfig.json --pretty --noEmit",
    "check-lint": "eslint . --ext ts --ext tsx --ext js",
    "lint": "eslint . --ext .js,.ts,.tsx",
    "lint:fix": "eslint . --ext .js,.ts,.tsx --fix"
  },
  "jest": {
    "preset": "ts-jest",
    "testEnvironment": "node",
    "testMatch": [
      "**/*.test.ts"
    ],
    "collectCoverageFrom": [
      "src/**/*.ts"
    ]
  },
  "keywords": [
    "testing",
    "mocking",
    "record",
    "playback",
    "snapshot"
  ],
  "author": "Andrew Lewin",
  "license": "MIT",
  "devDependencies": {
    "@commitlint/cli": "^19.6.1",
    "@commitlint/config-conventional": "^19.6.0",
    "@types/jest": "^29.0.0",
    "@types/node": "^18.0.0",
    "@typescript-eslint/eslint-plugin": "^5.62.0",
    "@typescript-eslint/parser": "^5.62.0",
    "commitizen": "^4.3.1",
    "cz-conventional-changelog": "^3.3.0",
    "eslint": "^8.57.0",
    "eslint-config-google": "^0.14.0",
    "eslint-config-next": "^12.1.6",
    "eslint-config-prettier": "^8.5.0",
    "eslint-plugin-prettier": "^4.0.0",
    "husky": "^9.1.7",
    "jest": "^29.0.0",
    "ts-jest": "^29.0.0",
    "typescript": "^4.9.0"
  },
  "files": [
    "dist",
    "README.md"
  ],
  "config": {
    "commitizen": {
      "path": "./node_modules/cz-conventional-changelog"
    }
  }
}

```

# README.md

```md
# Beatbox

Beatbox is a lightweight TypeScript library that records and replays function calls, making it perfect for testing, mocking, and debugging. It can capture the results of expensive operations, API calls, or complex computations and play them back instantly, significantly speeding up tests and development cycles.

## Features

- ðŸŽ¯ Record function calls and their results
- âš¡ Instant playback of previously recorded results
- ðŸ”„ Bypass mode for normal function execution
- ðŸ” Supports both synchronous and asynchronous functions
- ðŸ’¾ Persistent storage in JSON format with atomic writes
- ðŸ“ Full TypeScript support
- ðŸ›¡ï¸ Comprehensive error handling and recovery
- ðŸ” Secure argument hashing for storage
- ðŸ” Smart handling of circular references
- ðŸŽ­ Special type preservation (Set, Map, Date, RegExp)
- ðŸ“¦ Automatic backup of corrupted storage files
- âš ï¸ Graceful handling of non-serializable data

## Installation

\`\`\`bash
npm install beatbox-recorder
\`\`\`

## Quick Start

\`\`\`typescript
import { Beatbox, Mode } from 'beatbox-recorder';

// Create a new instance
const beatbox = new Beatbox('my-storage.json');

// Example function to wrap
const fetchUserData = async (userId: string) => {
  // Expensive API call
  const response = await fetch(`/api/users/${userId}`);
  return response.json();
};

// Wrap the function
const wrappedFetchUserData = beatbox.wrap(fetchUserData);

// Record mode: Actually makes API calls and saves results
beatbox.setMode(Mode.RECORD);
const userData = await wrappedFetchUserData('user123');

// Playback mode: Returns saved results instantly
beatbox.setMode(Mode.PLAYBACK);
const cachedData = await wrappedFetchUserData('user123');

// Bypass mode: Makes actual API calls again
beatbox.setMode(Mode.BYPASS);
const freshData = await wrappedFetchUserData('user123');
\`\`\`

## Use Cases

### Testing
- Record real API responses once and replay them in tests
- Make tests faster and more reliable
- Work offline with recorded data

### Development
- Cache expensive computations
- Speed up development cycles
- Debug complex function calls

### Mocking
- Create predictable test scenarios
- Simulate different API responses
- Test error handling

## API Reference

### Class: Beatbox

#### Constructor
\`\`\`typescript
new Beatbox(storageFile?: string)
\`\`\`
- `storageFile`: Optional path to storage JSON file (default: 'beatbox-storage.json')

#### Methods

##### setMode(mode: Mode)
Sets the operating mode of the wrapper:
- `Mode.BYPASS`: Direct function execution
- `Mode.RECORD`: Record function results
- `Mode.PLAYBACK`: Return recorded results

##### wrap<T>(fn: T): T
Wraps a function for recording/playback:
- Works with both sync and async functions
- Preserves original function signature
- Returns wrapped function with same type

## Storage Format

Results are stored in a JSON file with MD5 hashes of function arguments as keys. Special types are preserved with type information:

\`\`\`json
{
  "d41d8cd98f00b204e9800998ecf8427e": {
    "result": "cached value"
  },
  "a7b5f3e21d9c4f8g": {
    "value": [1, 2, 3],
    "__type": "Set"
  },
  "h8j2k4l6m8n0p2q4": {
    "value": "2024-01-01T00:00:00.000Z",
    "__type": "Date"
  }
\`\`\`

## Best Practices

1. **Version Control**
   - Consider adding storage files to .gitignore
   - Version control them separately if needed
   - Keep backup files (*.backup.*) in .gitignore

2. **Storage Management**
   - Regularly clean up old recordings and backup files
   - Use separate storage files for different test suites
   - Monitor storage file size for non-serializable data warnings

3. **Error Handling**
   - Always handle missing recording errors in playback mode
   - Consider fallback strategies for missing data
   - Check console warnings for serialization issues

4. **Security**
   - Don't record sensitive data
   - Clean sensitive information before recording
   - Monitor storage files for accidentally recorded sensitive data

5. **Type Handling**
   - Be aware of special type preservation for Set, Map, Date, etc.
   - Handle circular references appropriately
   - Consider implementing custom serialization for complex types

## Common Patterns

### Conditional Recording

\`\`\`typescript
if (process.env.NODE_ENV === 'test') {
  beatbox.setMode(Mode.PLAYBACK);
} else {
  beatbox.setMode(Mode.BYPASS);
}
\`\`\`

### Recording Sets

\`\`\`typescript
// Record a set of related calls
beatbox.setMode(Mode.RECORD);
await Promise.all([
  wrappedFn('test1'),
  wrappedFn('test2'),
  wrappedFn('test3')
]);
\`\`\`

### Handling Complex Types

\`\`\`typescript
// Sets and Maps are automatically preserved
const wrappedSet = beatbox.wrap(() => new Set([1, 2, 3]));
const result = wrappedSet(); // Will be restored as Set in playback

// Dates are preserved
const wrappedDate = beatbox.wrap(() => new Date());
const date = wrappedDate(); // Will be restored as Date in playback

// Handle circular references
const wrappedCircular = beatbox.wrap(() => {
  const obj: any = { a: 1 };
  obj.self = obj;
  return obj;
}); // Will be handled gracefully
\`\`\`

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

MIT License - see LICENSE file for details
```

# src\index.ts

```ts
import fs from 'fs/promises';
import crypto from 'crypto';

export enum Mode {
  BYPASS = 'BYPASS',
  RECORD = 'RECORD',
  PLAYBACK = 'PLAYBACK'
}

interface StorageData {
  [key: string]: any;
}

interface SerializationResult {
  success: boolean;
  data?: string;
  error?: string;
}

export class Beatbox {
  private storage: StorageData = {};
  private storageFile: string;
  private mode: Mode = Mode.BYPASS;
  private initialized: boolean = false;

  constructor(storageFile: string = 'beatbox-storage.json') {
    this.storageFile = storageFile;
  }

  setMode(mode: Mode) {
    this.mode = mode;
  }

  private generateHash(args: any[]): string {
    const argsStr = JSON.stringify(args, this.safeJsonReplacer);
    return crypto.createHash('md5').update(argsStr).digest('hex');
  }

  private safeJsonReplacer(key: string, value: any): any {
    if (value instanceof Set) {
      return {
        __type: 'Set',
        value: Array.from(value)
      };
    }
    if (value instanceof Map) {
      return {
        __type: 'Map',
        value: Array.from(value.entries())
      };
    }
    if (value instanceof Date) {
      return {
        __type: 'Date',
        value: value.toISOString()
      };
    }
    if (typeof value === 'function') {
      return {
        __type: 'Function',
        name: value.name || 'anonymous'
      };
    }
    if (value instanceof RegExp) {
      return {
        __type: 'RegExp',
        source: value.source,
        flags: value.flags
      };
    }
    if (value instanceof Error) {
      return {
        __type: 'Error',
        name: value.name,
        message: value.message,
        stack: value.stack
      };
    }
    if (value instanceof Promise) {
      return {
        __type: 'Promise',
        status: 'pending'
      };
    }
    // Handle circular references
    const seen = new WeakSet();
    if (typeof value === 'object' && value !== null) {
      if (seen.has(value)) {
        return '[Circular Reference]';
      }
      seen.add(value);
    }
    return value;
  }

  private safeJsonReviver(key: string, value: any): any {
    if (value && typeof value === 'object' && '__type' in value) {
      switch (value.__type) {
        case 'Set':
          return new Set(value.value);
        case 'Map':
          return new Map(value.value);
        case 'Date':
          return new Date(value.value);
        case 'RegExp':
          return new RegExp(value.source, value.flags);
        case 'Error':
          const error = new Error(value.message);
          error.name = value.name;
          error.stack = value.stack;
          return error;
        case 'Function':
          return function() { 
            throw new Error(`Cannot execute restored function '${value.name}'`);
          };
        case 'Promise':
          return Promise.reject(new Error('Cannot restore Promise object'));
        default:
          return value;
      }
    }
    return value;
  }

  private async trySerialize(data: any): Promise<SerializationResult> {
    try {
      const serialized = JSON.stringify(data, this.safeJsonReplacer);
      // Verify that it can be parsed back
      JSON.parse(serialized, this.safeJsonReviver);
      return { success: true, data: serialized };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown serialization error' 
      };
    }
  }

  private async loadStorage(): Promise<void> {
    if (this.initialized) return;

    try {
      const data = await fs.readFile(this.storageFile, 'utf-8');
      this.storage = JSON.parse(data, this.safeJsonReviver);
      this.initialized = true;
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        this.storage = {};
        this.initialized = true;
      } else if (error instanceof SyntaxError) {
        // Handle corrupted storage file
        const backup = `${this.storageFile}.backup.${Date.now()}`;
        await fs.rename(this.storageFile, backup);
        this.storage = {};
        this.initialized = true;
        console.warn(`Storage file was corrupted. Backed up to ${backup} and created new storage.`);
      } else {
        throw error;
      }
    }
  }

  private async saveStorage(): Promise<void> {
    const { success, data, error } = await this.trySerialize(this.storage);
    if (!success) {
      console.warn(`Failed to save storage: ${error}`);
      return;
    }
    
    try {
      const tempFile = `${this.storageFile}.tmp`;
      await fs.writeFile(tempFile, data!);
      await fs.rename(tempFile, this.storageFile);
    } catch (error) {
      console.error('Failed to save storage file:', error);
    }
  }

  wrap<T extends (...args: any[]) => any>(fn: T): T {
    const wrapper = async (...args: Parameters<T>): Promise<ReturnType<T>> => {
      await this.loadStorage();
      const hash = this.generateHash(args);

      switch (this.mode) {
        case Mode.BYPASS:
          return fn(...args);

        case Mode.RECORD: {
          const result = await fn(...args);
          const { success } = await this.trySerialize(result);
          if (success) {
            this.storage[hash] = result;
            await this.saveStorage();
          } else {
            console.warn('Failed to record non-serializable result');
          }
          return result;
        }

        case Mode.PLAYBACK:
          if (hash in this.storage) {
            return this.storage[hash];
          }
          throw new Error(`No recorded result found for arguments: ${JSON.stringify(args, null, 2)}`);

        default:
          throw new Error(`Invalid mode: ${this.mode}`);
      }
    };

    // Handle synchronous functions
    const syncWrapper = (...args: Parameters<T>): ReturnType<T> => {
      const hash = this.generateHash(args);

      switch (this.mode) {
        case Mode.BYPASS:
          return fn(...args);

        case Mode.RECORD: {
          const result = fn(...args);
          // Save asynchronously without blocking
          this.loadStorage().then(async () => {
            const { success } = await this.trySerialize(result);
            if (success) {
              this.storage[hash] = result;
              await this.saveStorage();
            } else {
              console.warn('Failed to record non-serializable result');
            }
          }).catch(console.error);
          return result;
        }

        case Mode.PLAYBACK:
          // Initialize storage synchronously for playback
          try {
            const data = require('fs').readFileSync(this.storageFile, 'utf-8');
            this.storage = JSON.parse(data, this.safeJsonReviver);
            this.initialized = true;
          } catch (error) {
            if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
              this.storage = {};
              this.initialized = true;
            } else if (error instanceof SyntaxError) {
              // Handle corrupted storage file
              const backup = `${this.storageFile}.backup.${Date.now()}`;
              require('fs').renameSync(this.storageFile, backup);
              this.storage = {};
              this.initialized = true;
              console.warn(`Storage file was corrupted. Backed up to ${backup} and created new storage.`);
            }
          }
          
          if (!(hash in this.storage)) {
            throw new Error(`No recorded result found for arguments: ${JSON.stringify(args, null, 2)}`);
          }
          return this.storage[hash];

        default:
          throw new Error(`Invalid mode: ${this.mode}`);
      }
    };

    // Determine if the original function is async
    const isAsync = fn.constructor.name === 'AsyncFunction';
    return (isAsync ? wrapper : syncWrapper) as T;
  }
}
```

# test-storage.json.backup.1734902670642

```1734902670642
corrupted json
```

# tests\index.test.ts

```ts
import { Beatbox, Mode } from '../src';
import fs from 'fs/promises';
import path from 'path';

describe('Beatbox', () => {
  const testStorageFile = 'test-storage.json';
  let beatbox: Beatbox;

  // Test functions
  const syncAdd = (a: number, b: number): number => a + b;
  const asyncAdd = async (a: number, b: number): Promise<number> => {
    await new Promise(resolve => setTimeout(resolve, 10));
    return a + b;
  };

  const syncError = (): never => {
    throw new Error('Sync error');
  };

  const asyncError = async (): Promise<never> => {
    await new Promise(resolve => setTimeout(resolve, 10));
    throw new Error('Async error');
  };

  beforeEach(async () => {
    beatbox = new Beatbox(testStorageFile);
    // Clear storage file
    try {
      await fs.unlink(testStorageFile);
    } catch (error) {
      // Ignore if file doesn't exist
    }
  });

  afterAll(async () => {
    try {
      await fs.unlink(testStorageFile);
    } catch (error) {
      // Ignore if file doesn't exist
    }
  });

  describe('Synchronous Function Tests', () => {
    describe('BYPASS Mode', () => {
      beforeEach(() => {
        beatbox.setMode(Mode.BYPASS);
      });

      test('should execute function normally', () => {
        const wrapped = beatbox.wrap(syncAdd);
        expect(wrapped(2, 3)).toBe(5);
      });

      test('should propagate errors', () => {
        const wrapped = beatbox.wrap(syncError);
        expect(() => wrapped()).toThrow('Sync error');
      });
    });

    describe('RECORD Mode', () => {
      beforeEach(() => {
        beatbox.setMode(Mode.RECORD);
      });

      test('should record function result', async () => {
        const wrapped = beatbox.wrap(syncAdd);
        const result = wrapped(2, 3);
        expect(result).toBe(5);

        // Wait for async storage
        await new Promise(resolve => setTimeout(resolve, 100));

        // Verify storage
        const storage = JSON.parse(await fs.readFile(testStorageFile, 'utf-8'));
        expect(Object.values(storage)[0]).toBe(5);
      });

      test('should record error result', async () => {
        const wrapped = beatbox.wrap(syncError);
        expect(() => wrapped()).toThrow('Sync error');

        // Wait for async storage
        await new Promise(resolve => setTimeout(resolve, 100));

        // Verify storage file doesn't exist or is empty
        try {
          const storage = JSON.parse(await fs.readFile(testStorageFile, 'utf-8'));
          expect(Object.keys(storage)).toHaveLength(0);
        } catch (error) {
          // File might not exist, which is fine for error cases
          if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
            throw error;
          }
        }
      });
    });

    describe('PLAYBACK Mode', () => {
      beforeEach(async () => {
        // Pre-record some data
        beatbox.setMode(Mode.RECORD);
        const wrapped = beatbox.wrap(syncAdd);
        wrapped(2, 3);
        await new Promise(resolve => setTimeout(resolve, 100));
        beatbox.setMode(Mode.PLAYBACK);
      });

      test('should return recorded result', () => {
        const wrapped = beatbox.wrap(syncAdd);
        expect(wrapped(2, 3)).toBe(5);
      });

      test('should throw error for missing recording', () => {
        const wrapped = beatbox.wrap(syncAdd);
        expect(() => wrapped(4, 5)).toThrow('No recorded result found');
      });
    });
  });

  describe('Asynchronous Function Tests', () => {
    describe('BYPASS Mode', () => {
      beforeEach(() => {
        beatbox.setMode(Mode.BYPASS);
      });

      test('should execute function normally', async () => {
        const wrapped = beatbox.wrap(asyncAdd);
        const result = await wrapped(2, 3);
        expect(result).toBe(5);
      });

      test('should propagate errors', async () => {
        const wrapped = beatbox.wrap(asyncError);
        await expect(wrapped()).rejects.toThrow('Async error');
      });
    });

    describe('RECORD Mode', () => {
      beforeEach(() => {
        beatbox.setMode(Mode.RECORD);
      });

      test('should record function result', async () => {
        const wrapped = beatbox.wrap(asyncAdd);
        const result = await wrapped(2, 3);
        expect(result).toBe(5);

        // Verify storage
        const storage = JSON.parse(await fs.readFile(testStorageFile, 'utf-8'));
        expect(Object.values(storage)[0]).toBe(5);
      });

      test('should record error result', async () => {
        const wrapped = beatbox.wrap(asyncError);
        await expect(wrapped()).rejects.toThrow('Async error');

        // Verify storage file doesn't exist or is empty
        try {
          const storage = JSON.parse(await fs.readFile(testStorageFile, 'utf-8'));
          expect(Object.keys(storage)).toHaveLength(0);
        } catch (error) {
          // File might not exist, which is fine for error cases
          if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
            throw error;
          }
        }
      });
    });

    describe('PLAYBACK Mode', () => {
      beforeEach(async () => {
        // Pre-record some data
        beatbox.setMode(Mode.RECORD);
        const wrapped = beatbox.wrap(asyncAdd);
        await wrapped(2, 3);
        beatbox.setMode(Mode.PLAYBACK);
      });

      test('should return recorded result', async () => {
        const wrapped = beatbox.wrap(asyncAdd);
        const result = await wrapped(2, 3);
        expect(result).toBe(5);
      });

      test('should throw error for missing recording', async () => {
        const wrapped = beatbox.wrap(asyncAdd);
        await expect(wrapped(4, 5)).rejects.toThrow('No recorded result found');
      });
    });
  });

  describe('Edge Cases', () => {
    test('should handle undefined arguments', async () => {
      const fn = (a?: number) => a ?? 0;
      const wrapped = beatbox.wrap(fn);

      beatbox.setMode(Mode.RECORD);
      expect(wrapped()).toBe(0);
      await new Promise(resolve => setTimeout(resolve, 100));

      beatbox.setMode(Mode.PLAYBACK);
      expect(wrapped()).toBe(0);
    });

    test('should handle object arguments', async () => {
      const fn = (obj: {x: number, y: number}) => obj.x + obj.y;
      const wrapped = beatbox.wrap(fn);

      beatbox.setMode(Mode.RECORD);
      expect(wrapped({x: 1, y: 2})).toBe(3);
      await new Promise(resolve => setTimeout(resolve, 100));

      beatbox.setMode(Mode.PLAYBACK);
      expect(wrapped({x: 1, y: 2})).toBe(3);
    });

    test('should handle array arguments', async () => {
      const fn = (arr: number[]) => arr.reduce((a, b) => a + b, 0);
      const wrapped = beatbox.wrap(fn);

      beatbox.setMode(Mode.RECORD);
      expect(wrapped([1, 2, 3])).toBe(6);
      await new Promise(resolve => setTimeout(resolve, 100));

      beatbox.setMode(Mode.PLAYBACK);
      expect(wrapped([1, 2, 3])).toBe(6);
    });

    test('should handle non-serializable results', async () => {
      const fn = () => {
        const set = new Set([1, 2, 3]);
        // Add circular reference to make it definitely non-serializable
        const obj: any = { set };
        obj.self = obj;
        return obj;
      };
      const wrapped = beatbox.wrap(fn);

      // In RECORD mode, it should still return the result but warn about serialization
      beatbox.setMode(Mode.RECORD);
      const result = wrapped();
      expect(result.set instanceof Set).toBe(true);
      await new Promise(resolve => setTimeout(resolve, 100));

      // In PLAYBACK mode, it should throw since the data wasn't recorded
      beatbox.setMode(Mode.PLAYBACK);
      expect(() => wrapped()).toThrow('No recorded result found');
    });
  });

  describe('Storage Management', () => {
    test('should handle missing storage file', async () => {
      // Ensure storage file doesn't exist
      try {
        await fs.unlink(testStorageFile);
      } catch (error) {
        // Ignore if file doesn't exist
      }

      const wrapped = beatbox.wrap(syncAdd);
      beatbox.setMode(Mode.PLAYBACK);
      expect(() => wrapped(1, 2)).toThrow('No recorded result found for arguments');
    });

    test('should handle corrupted storage file', async () => {
      // Write corrupted JSON
      await fs.writeFile(testStorageFile, 'corrupted json');
      
      const wrapped = beatbox.wrap(syncAdd);
      beatbox.setMode(Mode.PLAYBACK);
      expect(() => wrapped(1, 2)).toThrow();
    });

    test('should handle multiple storage instances', async () => {
      const beatbox1 = new Beatbox('storage1.json');
      const beatbox2 = new Beatbox('storage2.json');

      const wrapped1 = beatbox1.wrap(syncAdd);
      const wrapped2 = beatbox2.wrap(syncAdd);

      beatbox1.setMode(Mode.RECORD);
      beatbox2.setMode(Mode.RECORD);

      wrapped1(1, 2);
      wrapped2(3, 4);

      await new Promise(resolve => setTimeout(resolve, 100));

      beatbox1.setMode(Mode.PLAYBACK);
      beatbox2.setMode(Mode.PLAYBACK);

      expect(wrapped1(1, 2)).toBe(3);
      expect(wrapped2(3, 4)).toBe(7);

      // Cleanup
      await fs.unlink('storage1.json');
      await fs.unlink('storage2.json');
    });
  });
});
```

# tsconfig.json

```json
{
  "compilerOptions": {
    "target": "es2018",
    "module": "commonjs",
    "declaration": true,
    "outDir": "./dist",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

# tsconfig.tsbuildinfo

```tsbuildinfo
{"program":{"fileNames":[],"fileInfos":[],"options":{"alwaysStrict":true,"composite":true,"declaration":true,"experimentalDecorators":true,"inlineSourceMap":true,"inlineSources":true,"module":1,"noFallthroughCasesInSwitch":false,"noImplicitAny":true,"noImplicitReturns":true,"noImplicitThis":true,"noUnusedLocals":false,"noUnusedParameters":false,"strict":true,"strictNullChecks":true,"strictPropertyInitialization":false,"target":7},"referencedMap":[],"exportedModulesMap":[]},"version":"4.9.5"}
```

